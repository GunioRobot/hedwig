{"content":"<h1>Touch Events</h1>\n\n<p>SproutCore now supports multitouch.</p>\n\n<p>Views ought to implement four methods to support touch:</p>\n\n<ul>\n<li><code class='syntax js'><span class=\"variable\">touchStart</span></code></li>\n<li><code class='syntax js'><span class=\"variable\">touchEnd</span></code></li>\n<li><code class='syntax js'><span class=\"variable\">touchCancelled</span></code></li>\n<li><code class='syntax js'><span class=\"variable\">touchesDragged</span></code></li>\n</ul>\n\n<p>The methods are what they sound like. Really.</p>\n\n<p>So, understanding that, why do three start with <code class='syntax js'><span class=\"variable\">touch</span></code>-, and one starts with <code class='syntax js'><span class=\"variable\">touches</span></code>-? There is\nindeed a very logical and important reason: the ones with names starting with <code class='syntax js'><span class=\"variable\">touch</span></code> deal\nwith single touches at a time. The one starting with \"touches\" deals with potentially multiple touches.</p>\n\n<h2>Finding the Touch Responder</h2>\n\n<p>When a user first touches the screen, a touch responder for that touch is found. The touch responder\nis the view that receives all further touch events for that touch, such as touchesDragged, touchEnd,\nand touchCancelled.</p>\n\n<p>The process is simple. First, it finds out what view the touch was targeted at originally. Then it\ndoes some special stuff (which we'll discuss under 'Capturing Touch') for special views like <code>SC.ScrollView</code>s. \nFinally, it starts at the target view and works up the view tree until it finds a view that <em>accepts</em> the touch.\nThis view becomes the touch responder for the touch, and will receive further events \n(<code class='syntax js'><span class=\"variable\">touchStart</span></code>, <code class='syntax js'><span class=\"variable\">touchesDragged</span></code>, and <code class='syntax js'><span class=\"variable\">touchCancelled</span></code>);</p>\n\n<h1>Accepting the Touch: touchStart</h1>\n\n<p>To accept a touch, a view must return <code class='syntax js'><span class=\"class\">YES</span></code> from <code class='syntax js'><span class=\"variable\">touchStart</span></code>.</p>\n\n<p>How does a view know if it wants to accept the touch? You are possibly familiar with <code class='syntax js'><span class=\"variable\">mouseDown</span></code>'s signature:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">mouseDown</span>: <span class=\"keyword\">function</span>(<span class=\"variable\">evt</span>) {\n</code></pre>\n\n<p>With <code class='syntax js'><span class=\"variable\">mouseDown</span></code>, you can decide whether or not to accept the touch based on, for instance, the <code class='syntax js'><span class=\"variable\">pageX</span></code> and <code class='syntax js'><span class=\"class\">Y</span></code>\nof the mouse.</p>\n\n<p>touchStart's signature is slightly different:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">touchStart</span>: <span class=\"keyword\">function</span>(<span class=\"variable\">touch</span>) {\n</code></pre>\n\n<p><code class='syntax js'><span class=\"variable\">touchStart</span></code>, instead of being passed the raw event, is passed an <code class='syntax js'><span class=\"class\">SC</span>.<span class=\"class\">Touch</span></code> object. </p>\n\n<h2>Tip: set acceptsMultitouch to YES to track multiple touches</h2>\n\n<p>By default, views will only receive <code class='syntax js'><span class=\"variable\">touchStart</span></code> for the <em>first</em> finger to touch them,\nand touchEnd for the <em>last</em> finger to lift from them. This is to make it simpler to\nhandle views such as buttons, which don't need to track multiple touches.</p>\n\n<p>To track multiple touches, set your view's <code class='syntax js'><span class=\"variable\">acceptsMultitouch</span></code> property to <code class='syntax js'><span class=\"class\">YES</span></code>.</p>\n\n<h2>SC.Touch</h2>\n\n<p>SC.Touch represents the touch from the time the user puts their finger on the screen until the time they lift it.</p>\n\n<p>The touch object acts like an event object in many ways. It has many other useful things, as well:</p>\n\n<ul>\n<li><code class='syntax js'><span class=\"variable\">pageX</span></code> and <code class='syntax js'><span class=\"variable\">pageY</span></code> for the touch</li>\n<li><code class='syntax js'><span class=\"variable\">event</span></code>: if in an event cycle, this contains the event. Otherwise, it is <code class='syntax js'><span class=\"variable\">undefined</span></code>.</li>\n<li><code class='syntax js'><span class=\"variable\">preventDefault</span></code>: if the touch is connected with an event, this calls <code class='syntax js'><span class=\"variable\">preventDefault</span>()</code> on the event.</li>\n<li><code class='syntax js'><span class=\"variable\">touchesForView</span>(<span class=\"variable\">view</span>)</code>: when supplied a view, will find all touches that the view is the\ntouch responder for. It is a CoreSet; to get an array, call <code class='syntax js'>.<span class=\"variable\">toArray</span></code> on the result.</li>\n</ul>\n\n<p>Note: If you call <code class='syntax js'><span class=\"variable\">touchesForView</span>(<span class=\"this\">this</span>)</code>, the touch supplied to <code class='syntax js'><span class=\"variable\">touchStart</span></code> will not be in the set,\nas the view has not accepted it yet.</p>\n\n<h1>Tracking Movement: touchesDragged</h1>\n\n<p><code class='syntax js'><span class=\"variable\">touchesDragged</span></code> will be called on a touch's touch responder every time a touch \n(or multiple touches) moves. Unlike <code class='syntax js'><span class=\"variable\">touchStart</span></code>, <code class='syntax js'><span class=\"variable\">touchEnd</span></code>, and <code class='syntax js'><span class=\"variable\">touchCancelled</span></code>, which are\ncalled once per touch, <code class='syntax js'><span class=\"variable\">touchesDragged</span></code> is called once per event cycle, and can be called\nwith multiple touches.</p>\n\n<p><code class='syntax js'><span class=\"variable\">touchesDragged</span></code> signature is:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">touchesDragged</span>: <span class=\"keyword\">function</span>(<span class=\"variable\">evt</span>, <span class=\"variable\">touches</span>) {\n</code></pre>\n\n<p><code class='syntax js'><span class=\"variable\">evt</span></code> is relatively standard, except for the following:</p>\n\n<ul>\n<li><code class='syntax js'><span class=\"variable\">pageX</span></code> and <code class='syntax js'><span class=\"variable\">pageY</span></code> are set to the <code class='syntax js'><span class=\"variable\">pageX</span></code> and <code class='syntax js'><span class=\"variable\">pageY</span></code> of the first touch</li>\n<li>the event has a <code class='syntax js'><span class=\"variable\">touchesForView</span></code> method (though you probably won't use it\u2013see \"touches\")</li>\n</ul>\n\n<p>In addition to the event, the CoreSet of touches for the view (that is, for which the view\nis touch responder) is provided (this is why you don't have to call <code class='syntax js'><span class=\"variable\">touchesForView</span></code>).\nIt is a CoreSet of <code class='syntax js'><span class=\"class\">SC</span>.<span class=\"class\">Touch</span></code> objects (the same as if you called <code class='syntax js'><span class=\"variable\">touchesForView</span></code>).</p>\n\n<h1>Ending Touches: touchEnd</h1>\n\n<p>Do I really need to explain? Like <code class='syntax js'><span class=\"variable\">touchStart</span></code>, it is passed an <code class='syntax js'><span class=\"class\">SC</span>.<span class=\"class\">Touch</span></code> object. This touch will\nnot be in the set of touches for the view, because it has ended.</p>\n\n<h1>Cancelling Touches: touchCancelled</h1>\n\n<p>Basically, <code class='syntax js'><span class=\"variable\">touchCancelled</span></code> is like <code class='syntax js'><span class=\"variable\">touchEnd</span></code>, except it occurs when the touch was cancelled for\nsome other reason. For instance, if a button receives <code class='syntax js'><span class=\"variable\">touchCancelled</span></code>, it should make the button\nstop being active, but should <em>not</em> trigger the button's action.</p>\n\n<h1>Giving Up Touches</h1>\n\n<p>Why would you want to give up a touch? Imagine that your control is inside a <code class='syntax js'><span class=\"class\">SC</span>.<span class=\"class\">ScrollView</span></code>:\nif the touch moves too much, perhaps it should be considered a scroll, rather than an\naction for your control.</p>\n\n<p>From touchesDragged, you would give up touch responder status through a line like this:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">someTouch</span>.<span class=\"variable\">makeTouchResponder</span>(<span class=\"variable\">someTouch</span>.<span class=\"variable\">nextTouchResponder</span>);\n</code></pre>\n\n<p>The touch's nextTouchResponder is the responder that is the <em>parent</em> touch responder; through\ndevious trickery (see <em>Capturing Touches</em>), ScrollView receives touch responder status <em>before</em>\nother views; further, it doesn't just hand touch responder status to the target view (your view)--\nit adds the responder to a stack of touch responders for the touch, so the responders can easily\nreturn to their parent responder (which is what you do with the above line of code.)</p>\n\n<p>Remember, though, that touchesDragged is called with a set of touches. It is really easy\nto change the responder for all of the touches simultaneously, should you wish to do so:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">touches</span>.<span class=\"variable\">forEach</span>(<span class=\"keyword\">function</span>(<span class=\"variable\">touch</span>){\n  <span class=\"variable\">touch</span>.<span class=\"variable\">makeTouchResponder</span>(<span class=\"variable\">touch</span>.<span class=\"variable\">nextTouchResponder</span>);\n});\n</code></pre>\n\n<p>Perhaps you want to pass control only if the responder is scrollable:</p>\n\n<pre><code class='syntax js'><span class=\"keyword\">if</span> (<span class=\"variable\">touch</span>.<span class=\"variable\">nextTouchResponder</span> &amp;&amp; <span class=\"variable\">touch</span>.<span class=\"variable\">nextTouchResponder</span>.<span class=\"variable\">isScrollable</span>) {\n    <span class=\"variable\">touch</span>.<span class=\"variable\">makeTouchResponder</span>(<span class=\"variable\">touch</span>.<span class=\"variable\">nextTouchResponder</span>);\n}\n</code></pre>\n\n<p>You can also stack your touch responder on so that child views may easily return control back\nto your view:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">touch</span>.<span class=\"variable\">makeTouchResponder</span>(<span class=\"variable\">touch</span>.<span class=\"variable\">nextTouchResponder</span>, <span class=\"class\">YES</span>); <span class=\"comment\">// YES as shouldStack argument</span>\n</code></pre>\n\n<p><strong>If your view is no longer in the touch responder stack, touchCancelled will be called upon it.</strong>\nThis means that, if shouldStack is YES (and as such the view was not removed), no touchCancelled\nwould be called; on the other hand, if you were returning control to the original view (returning to\nthe scroll view, for example), touchCancelled will be called.</p>\n\n<p>Also note that, when touchEnd occurs, it will trigger touchEnd only for the main touchResponder; all\nother responders will get touchCancelled.</p>\n\n<h1>Advanced: Capturing Touches</h1>\n\n<p>Implementing a Scroll view? You'll need to capture the touch before the target view gets it.</p>\n\n<p>This is because Scroll views have some subtle quirks. For instance, a touch should not pass\nthrough to the actual target until a split-second has passed&emdash;this is to prevent flicker should\nthe user decide to scroll rather than touch the target. Also, it needs to add itself to the\ntouch responder stack <em>before</em> the target view, so that the target view can hand control back\nsimply as discussed above.</p>\n\n<p>The first part&emdash;capturing the touch&emdash;is simple. Before starting at the target view and working its\nway up to the root calling touchStart, SproutCore's touch events go the opposite direction, starting\nat the root and working their way down to the target, calling a method named captureTouch:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">captureTouch</span>: <span class=\"keyword\">function</span>(<span class=\"variable\">touch</span>) {\n</code></pre>\n\n<p>If the view returns YES, the touchStart event will be sent directly to it.</p>\n\n<p>You could then use invokeLater to wait that split-second. But then what? You don't actually\nknow what the target view should be. What you need is to start at the original target, and\ndo the whole working up to it calling captureTouch and work down from it calling touchStart\nthing&emdash;but this time, starting from your own view, rather than the root. </p>\n\n<p>Thankfully, you can do this in one line of code:</p>\n\n<pre><code class='syntax js'><span class=\"variable\">touch</span>.<span class=\"variable\">captureTouch</span>(<span class=\"this\">this</span>, <span class=\"class\">YES</span>); <span class=\"comment\">// the YES means stack, which I'm guessing you'd want to do</span>\n<span class=\"comment\">// so that the new view can easily pass control back to this...</span>\n<span class=\"comment\">// ... but you may know better than me</span>\n</code></pre>\n\n<p>If the view returns the event back to you, your view will begin getting touchesDragged events and\nwill receive touchEnd when the touch ends (you will not receive another touchStart event, however). \nOtherwise, your view will receive a touchCancelled when the touch ends.</p>","errors":[],"demos":{},"articleDirectory":"articles/touch/","outputDirectory":"build/","title":"Touch Events"}